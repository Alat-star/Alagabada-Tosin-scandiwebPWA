{"version":3,"file":"static/js/336.d548836a.chunk.js","mappings":"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","sources":["../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/kinds.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/parser.mjs","../node_modules/graphql-tag/src/index.ts","../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../node_modules/@apollo/src/react/parser/index.ts","../node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts","../node_modules/@apollo/src/react/hooks/useApolloClient.ts","../node_modules/@apollo/src/react/hooks/useQuery.ts","../node_modules/@apollo/src/react/components/Query.tsx","../node_modules/@apollo/src/react/hoc/hoc-utils.tsx","../node_modules/@apollo/src/react/components/Mutation.tsx","../node_modules/@apollo/src/react/hooks/useMutation.ts","../node_modules/@apollo/src/react/components/Subscription.tsx","../node_modules/@apollo/src/react/hooks/useSubscription.ts","../node_modules/@apollo/src/react/hoc/graphql.tsx","../node_modules/@apollo/src/react/hoc/mutation-hoc.tsx","../node_modules/@apollo/src/react/hoc/subscription-hoc.tsx","../node_modules/@apollo/src/react/hoc/query-hoc.tsx"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport default function isObjectLike(value) {\n  return _typeof(value) == 'object' && value !== null;\n}\n","/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n","import { getLocation } from \"./location.mjs\";\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var subLineIndex = Math.floor(columnNum / 80);\n    var subLineColumnNum = columnNum % 80;\n    var subLines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function (subLine) {\n      return ['', subLine];\n    }), [[' ', whitespace(subLineColumnNum - 1) + '^'], ['', subLines[subLineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return leftPad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction leftPad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n","function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport { getLocation } from \"../language/location.mjs\";\nimport { printLocation, printSourceLocation } from \"../language/printLocation.mjs\";\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport var GraphQLError = /*#__PURE__*/function (_Error) {\n  _inherits(GraphQLError, _Error);\n\n  var _super = _createSuper(GraphQLError);\n\n  /**\n   * An array of { line, column } locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n  function GraphQLError(message, nodes, source, positions, path, originalError, extensions) {\n    var _nodeLocations, _nodeLocations2, _nodeLocations3;\n\n    var _this;\n\n    _classCallCheck(this, GraphQLError);\n\n    _this = _super.call(this, message);\n    _this.name = 'GraphQLError';\n    _this.originalError = originalError !== null && originalError !== void 0 ? originalError : undefined; // Compute list of blame nodes.\n\n    _this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);\n    var nodeLocations = [];\n\n    for (var _i2 = 0, _ref3 = (_this$nodes = _this.nodes) !== null && _this$nodes !== void 0 ? _this$nodes : []; _i2 < _ref3.length; _i2++) {\n      var _this$nodes;\n\n      var _ref4 = _ref3[_i2];\n      var loc = _ref4.loc;\n\n      if (loc != null) {\n        nodeLocations.push(loc);\n      }\n    }\n\n    nodeLocations = undefinedIfEmpty(nodeLocations); // Compute locations in the source for the given nodes/positions.\n\n    _this.source = source !== null && source !== void 0 ? source : (_nodeLocations = nodeLocations) === null || _nodeLocations === void 0 ? void 0 : _nodeLocations[0].source;\n    _this.positions = positions !== null && positions !== void 0 ? positions : (_nodeLocations2 = nodeLocations) === null || _nodeLocations2 === void 0 ? void 0 : _nodeLocations2.map(function (loc) {\n      return loc.start;\n    });\n    _this.locations = positions && source ? positions.map(function (pos) {\n      return getLocation(source, pos);\n    }) : (_nodeLocations3 = nodeLocations) === null || _nodeLocations3 === void 0 ? void 0 : _nodeLocations3.map(function (loc) {\n      return getLocation(loc.source, loc.start);\n    });\n    _this.path = path !== null && path !== void 0 ? path : undefined;\n    var originalExtensions = originalError === null || originalError === void 0 ? void 0 : originalError.extensions;\n\n    if (extensions == null && isObjectLike(originalExtensions)) {\n      _this.extensions = _objectSpread({}, originalExtensions);\n    } else {\n      _this.extensions = extensions !== null && extensions !== void 0 ? extensions : {};\n    } // By being enumerable, JSON.stringify will include bellow properties in the resulting output.\n    // This ensures that the simplest possible GraphQL service adheres to the spec.\n\n\n    Object.defineProperties(_assertThisInitialized(_this), {\n      message: {\n        enumerable: true\n      },\n      locations: {\n        enumerable: _this.locations != null\n      },\n      path: {\n        enumerable: _this.path != null\n      },\n      extensions: {\n        enumerable: _this.extensions != null && Object.keys(_this.extensions).length > 0\n      },\n      name: {\n        enumerable: false\n      },\n      nodes: {\n        enumerable: false\n      },\n      source: {\n        enumerable: false\n      },\n      positions: {\n        enumerable: false\n      },\n      originalError: {\n        enumerable: false\n      }\n    }); // Include (non-enumerable) stack trace.\n\n    if (originalError !== null && originalError !== void 0 && originalError.stack) {\n      Object.defineProperty(_assertThisInitialized(_this), 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true\n      });\n      return _possibleConstructorReturn(_this);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError);\n    } else {\n      Object.defineProperty(_assertThisInitialized(_this), 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(GraphQLError, [{\n    key: \"toString\",\n    value: function toString() {\n      return printError(this);\n    } // FIXME: workaround to not break chai comparisons, should be remove in v16\n    // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n\n  }, {\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'Object';\n    }\n  }]);\n\n  return GraphQLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\n\nexport function printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i4 = 0, _error$nodes2 = error.nodes; _i4 < _error$nodes2.length; _i4++) {\n      var node = _error$nodes2[_i4];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i6 = 0, _error$locations2 = error.locations; _i6 < _error$locations2.length; _i6++) {\n      var location = _error$locations2[_i6];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n","import { GraphQLError } from \"./GraphQLError.mjs\";\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n","/**\n * The set of allowed kind values for AST nodes.\n */\nexport var Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport var TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n","/**\n * The set of allowed directive location values.\n */\nexport var DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n","import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Token } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"./blockString.mjs\";\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport var Lexer = /*#__PURE__*/function () {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  function Lexer(source) {\n    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n\n  var _proto = Lexer.prototype;\n\n  _proto.advance = function advance() {\n    this.lastToken = this.token;\n    var token = this.token = this.lookahead();\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n  ;\n\n  _proto.lookahead = function lookahead() {\n    var token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        var _token$next;\n\n        // Note: next is only mutable during parsing, so we cast to allow this.\n        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  };\n\n  return Lexer;\n}();\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = prev.end;\n\n  while (pos < bodyLength) {\n    var code = body.charCodeAt(pos);\n    var _line = lexer.line;\n\n    var _col = 1 + pos - lexer.lineStart; // SourceCharacter\n\n\n    switch (code) {\n      case 0xfeff: // <BOM>\n\n      case 9: //   \\t\n\n      case 32: //  <space>\n\n      case 44:\n        //  ,\n        ++pos;\n        continue;\n\n      case 10:\n        //  \\n\n        ++pos;\n        ++lexer.line;\n        lexer.lineStart = pos;\n        continue;\n\n      case 13:\n        //  \\r\n        if (body.charCodeAt(pos + 1) === 10) {\n          pos += 2;\n        } else {\n          ++pos;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = pos;\n        continue;\n\n      case 33:\n        //  !\n        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);\n\n      case 35:\n        //  #\n        return readComment(source, pos, _line, _col, prev);\n\n      case 36:\n        //  $\n        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);\n\n      case 38:\n        //  &\n        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);\n\n      case 40:\n        //  (\n        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);\n\n      case 41:\n        //  )\n        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);\n\n      case 46:\n        //  .\n        if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);\n        }\n\n        break;\n\n      case 58:\n        //  :\n        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);\n\n      case 61:\n        //  =\n        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);\n\n      case 64:\n        //  @\n        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);\n\n      case 91:\n        //  [\n        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);\n\n      case 93:\n        //  ]\n        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);\n\n      case 123:\n        // {\n        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);\n\n      case 124:\n        // |\n        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);\n\n      case 125:\n        // }\n        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);\n\n      case 34:\n        //  \"\n        if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n          return readBlockString(source, pos, _line, _col, prev, lexer);\n        }\n\n        return readString(source, pos, _line, _col, prev);\n\n      case 45: //  -\n\n      case 48: //  0\n\n      case 49: //  1\n\n      case 50: //  2\n\n      case 51: //  3\n\n      case 52: //  4\n\n      case 53: //  5\n\n      case 54: //  6\n\n      case 55: //  7\n\n      case 56: //  8\n\n      case 57:\n        //  9\n        return readNumber(source, pos, code, _line, _col, prev);\n\n      case 65: //  A\n\n      case 66: //  B\n\n      case 67: //  C\n\n      case 68: //  D\n\n      case 69: //  E\n\n      case 70: //  F\n\n      case 71: //  G\n\n      case 72: //  H\n\n      case 73: //  I\n\n      case 74: //  J\n\n      case 75: //  K\n\n      case 76: //  L\n\n      case 77: //  M\n\n      case 78: //  N\n\n      case 79: //  O\n\n      case 80: //  P\n\n      case 81: //  Q\n\n      case 82: //  R\n\n      case 83: //  S\n\n      case 84: //  T\n\n      case 85: //  U\n\n      case 86: //  V\n\n      case 87: //  W\n\n      case 88: //  X\n\n      case 89: //  Y\n\n      case 90: //  Z\n\n      case 95: //  _\n\n      case 97: //  a\n\n      case 98: //  b\n\n      case 99: //  c\n\n      case 100: // d\n\n      case 101: // e\n\n      case 102: // f\n\n      case 103: // g\n\n      case 104: // h\n\n      case 105: // i\n\n      case 106: // j\n\n      case 107: // k\n\n      case 108: // l\n\n      case 109: // m\n\n      case 110: // n\n\n      case 111: // o\n\n      case 112: // p\n\n      case 113: // q\n\n      case 114: // r\n\n      case 115: // s\n\n      case 116: // t\n\n      case 117: // u\n\n      case 118: // v\n\n      case 119: // w\n\n      case 120: // x\n\n      case 121: // y\n\n      case 122:\n        // z\n        return readName(source, pos, _line, _col, prev);\n    }\n\n    throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n  }\n\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n\n  if (code === 46 || isNameStart(code)) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n} // _ A-Z a-z\n\n\nfunction isNameStart(code) {\n  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;\n}\n","import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Location } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { Source, isSource } from \"./source.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var _this$_options2;\n\n    if (!this.expectOptionalKeyword('implements')) {\n      return [];\n    }\n\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {\n      var types = []; // Optional leading ampersand\n\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));\n\n      return types;\n    }\n\n    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3;\n\n    // Legacy support for the SDL?\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n  ;\n\n  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}\n","import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}","import { invariant } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments: DefinitionNode[] = []\n  const queries: DefinitionNode[] = []\n  const mutations: DefinitionNode[] = []\n  const subscriptions: DefinitionNode[] = []\n\n  for (const x of document.definitions) {\n    if (x.kind === 'FragmentDefinition') {\n      fragments.push(x);\n      continue\n    }\n\n    if (x.kind === 'OperationDefinition') {\n      switch (x.operation) {\n        case 'query':\n          queries.push(x);\n          break;\n        case 'mutation':\n          mutations.push(x);\n          break;\n        case 'subscription':\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a ${requiredOperationName} requires a graphql ` +\n      `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n  );\n}\n\n","import { invariant } from '../../utilities/globals';\nimport * as React from 'react';\n\nimport { canUseLayoutEffect } from '../../utilities';\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType = realHook || ((\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n) => {\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot();\n  if (\n    // DEVIATION: Using our own __DEV__ polyfill (from ../../utilities/globals).\n    __DEV__ &&\n    !didWarnUncachedGetSnapshot &&\n    // DEVIATION: Not using Object.is because we know our snapshots will never\n    // be exotic primitive values like NaN, which is !== itself.\n    value !== getSnapshot()\n  ) {\n    didWarnUncachedGetSnapshot = true;\n    // DEVIATION: Using invariant.error instead of console.error directly.\n    invariant.error(\n      'The result of getSnapshot should be cached to avoid an infinite loop',\n    );\n  }\n\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{inst}, forceUpdate] = React.useState({inst: {value, getSnapshot}});\n\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  if (canUseLayoutEffect) {\n    // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n    // which may seem like a conditional hook, but this code ends up behaving\n    // unconditionally (one way or the other) because canUseLayoutEffect is\n    // constant.\n    React.useLayoutEffect(() => {\n      Object.assign(inst, { value, getSnapshot });\n      // Whenever getSnapshot or subscribe changes, we need to check in the\n      // commit phase if there was an interleaved mutation. In concurrent mode\n      // this can happen all the time, but even in synchronous mode, an earlier\n      // effect may have mutated the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    }, [subscribe, value, getSnapshot]);\n  } else {\n    Object.assign(inst, { value, getSnapshot });\n  }\n\n  React.useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({inst});\n    }\n\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(function handleStoreChange() {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst});\n      }\n    });\n  }, [subscribe]);\n\n  return value;\n});\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n","import { invariant } from '../../utilities/globals';\nimport { useContext } from 'react';\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from '../context';\n\nexport function useApolloClient(\n  override?: ApolloClient<object>,\n): ApolloClient<object> {\n  const context = useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n    'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n    'instance in via options.',\n  );\n\n  return client;\n}\n","import { invariant } from '../../utilities/globals';\n\nimport {\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables, WatchQueryFetchPolicy } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, canUseWeakSet, compact, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  }\n\n  asyncUpdate() {\n    return new Promise<QueryResult<TData, TVariables>>(resolve => {\n      this.asyncResolveFns.add(resolve);\n      this.optionsToIgnoreOnce.add(this.watchQueryOptions);\n      this.forceUpdate();\n    });\n  }\n\n  private asyncResolveFns = new Set<\n    (result: QueryResult<TData, TVariables>) => void\n  >();\n\n  private optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)<\n    WatchQueryOptions<TVariables, TData>\n  >();\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        return () => subscription.unsubscribe();\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    const queryResult = this.toQueryResult(result);\n\n    if (!queryResult.loading && this.asyncResolveFns.size) {\n      this.asyncResolveFns.forEach(resolve => resolve(queryResult));\n      this.asyncResolveFns.clear();\n    }\n\n    return queryResult;\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    // To force this equality test to \"fail,\" thereby reliably triggering\n    // observable.reobserve, add any current WatchQueryOptions object(s) you\n    // want to be ignored to this.optionsToIgnoreOnce. A similar effect could be\n    // achieved by nullifying this.watchQueryOptions so the equality test\n    // immediately fails because currentWatchQueryOptions is null, but this way\n    // we can promise a truthy this.watchQueryOptions at all times.\n    if (\n      this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||\n      !equal(watchQueryOptions, currentWatchQueryOptions)\n    ) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // As advertised in the -Once of this.optionsToIgnoreOnce, this trick is\n        // only good for one forced execution of observable.reobserve per\n        // ignored WatchQueryOptions object, though it is unlikely we will ever\n        // see this exact currentWatchQueryOptions object again here, since we\n        // just replaced this.watchQueryOptions with watchQueryOptions.\n        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<\n      Partial<WatchQueryOptions<TVariables, TData>>\n    > = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(\n      this.observable && this.observable.options,\n      this.watchQueryOptions,\n    ));\n\n    return toMerge.reduce(\n      mergeOptions\n    ) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    displayName,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery(this.getObsQueryOptions());\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false ||\n      this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      if (result.error) {\n        this.onError(result.error);\n      } else if (result.data) {\n        this.onCompleted(result.data);\n      }\n    }\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n","import * as PropTypes from 'prop-types';\n\nimport { OperationVariables } from '../../core';\nimport { QueryComponentOptions } from './types';\nimport { useQuery } from '../hooks';\n\nexport function Query<TData = any, TVariables = OperationVariables>(\n  props: QueryComponentOptions<TData, TVariables>\n) {\n  const { children, query, ...options } = props;\n  const result = useQuery(query, options);\n  return result ? children(result as any) : null;\n}\n\nexport interface Query<TData, TVariables> {\n  propTypes: PropTypes.InferProps<QueryComponentOptions<TData, TVariables>>;\n}\n\nQuery.propTypes = {\n  client: PropTypes.object,\n  children: PropTypes.func.isRequired,\n  fetchPolicy: PropTypes.string,\n  notifyOnNetworkStatusChange: PropTypes.bool,\n  onCompleted: PropTypes.func,\n  onError: PropTypes.func,\n  pollInterval: PropTypes.number,\n  query: PropTypes.object.isRequired,\n  variables: PropTypes.object,\n  ssr: PropTypes.bool,\n  partialRefetch: PropTypes.bool,\n  returnPartialData: PropTypes.bool\n} as Query<any, any>[\"propTypes\"];\n","import { invariant } from '../../utilities/globals';\nimport * as React from 'react';\nimport { OperationVariables } from '../../core';\nimport { IDocumentDefinition } from '../parser';\n\nexport const defaultMapPropsToOptions = () => ({});\nexport const defaultMapResultToProps: <P>(props: P) => P = props => props;\nexport const defaultMapPropsToSkip = () => false;\n\nexport function getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport function calculateVariablesFromProps<TProps>(\n  operation: IDocumentDefinition,\n  props: TProps\n) {\n  let variables: OperationVariables = {};\n  for (let { variable, type } of operation.variables) {\n    if (!variable.name || !variable.name.value) continue;\n\n    const variableName = variable.name.value;\n    const variableProp = (props as any)[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    // Allow optional props\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n  return variables;\n}\n\nexport type RefSetter<TChildProps> = (\n  ref: React.ComponentClass<TChildProps>\n) => void | void;\n\n// base class for hocs to easily manage refs\nexport class GraphQLBase<\n  TProps,\n  TChildProps,\n  TState = any\n> extends React.Component<TProps, TState> {\n  public withRef: boolean = false;\n  // wrapped instance\n  private wrappedInstance?: React.ComponentClass<TChildProps>;\n\n  constructor(props: TProps) {\n    super(props);\n    this.setWrappedInstance = this.setWrappedInstance.bind(this);\n  }\n\n  getWrappedInstance() {\n    invariant(\n      this.withRef,\n      `To access the wrapped instance, you need to specify ` +\n        `{ withRef: true } in the options`\n    );\n\n    return this.wrappedInstance;\n  }\n\n  setWrappedInstance(ref: React.ComponentClass<TChildProps>) {\n    this.wrappedInstance = ref;\n  }\n}\n","import * as PropTypes from 'prop-types';\n\nimport { OperationVariables } from '../../core';\nimport { MutationComponentOptions } from './types';\nimport { useMutation } from '../hooks';\n\nexport function Mutation<TData = any, TVariables = OperationVariables>(\n  props: MutationComponentOptions<TData, TVariables>\n) {\n  const [runMutation, result] = useMutation(props.mutation, props);\n  return props.children ? props.children(runMutation, result) : null;\n}\n\nexport interface Mutation<TData, TVariables> {\n  propTypes: PropTypes.InferProps<MutationComponentOptions<TData, TVariables>>;\n}\n\nMutation.propTypes = {\n  mutation: PropTypes.object.isRequired,\n  variables: PropTypes.object,\n  optimisticResponse: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n  refetchQueries: PropTypes.oneOfType([\n    PropTypes.arrayOf(\n      PropTypes.oneOfType([PropTypes.string, PropTypes.object])\n    ),\n    PropTypes.func\n  ]),\n  awaitRefetchQueries: PropTypes.bool,\n  update: PropTypes.func,\n  children: PropTypes.func.isRequired,\n  onCompleted: PropTypes.func,\n  onError: PropTypes.func,\n  fetchPolicy: PropTypes.string,\n} as Mutation<any, any>[\"propTypes\"];\n","import { useCallback, useEffect, useRef, useState } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n} from '../types/types';\n\nimport {\n  ApolloCache,\n  DefaultContext,\n  mergeOptions,\n  OperationVariables,\n} from '../../core';\nimport { equal } from '@wry/equality';\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { ApolloError } from '../../errors';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<TData, TVariables, TContext>,\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = useState<Omit<MutationResult, 'reset'>>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = useCallback((\n    executeOptions: MutationFunctionOptions<\n      TData,\n      TVariables,\n      TContext,\n      TCache\n    > = {}\n  ) => {\n    const {client, options, mutation} = ref.current;\n    const baseOptions = { ...options, mutation };\n    if (!ref.current.result.loading && !baseOptions.ignoreResults) {\n      setResult(ref.current.result = {\n        loading: true,\n        error: void 0,\n        data: void 0,\n        called: true,\n        client,\n      });\n    }\n\n    const mutationId = ++ref.current.mutationId;\n    const clientOptions = mergeOptions(\n      baseOptions,\n      executeOptions as any,\n    );\n\n    return client.mutate(clientOptions).then((response) => {\n      const { data, errors } = response;\n      const error =\n        errors && errors.length > 0\n          ? new ApolloError({ graphQLErrors: errors })\n          : void 0;\n\n      if (\n        mutationId === ref.current.mutationId &&\n        !clientOptions.ignoreResults\n      ) {\n        const result = {\n          called: true,\n          loading: false,\n          data,\n          error,\n          client,\n        };\n\n        if (ref.current.isMounted && !equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      ref.current.options?.onCompleted?.(response.data!);\n      executeOptions.onCompleted?.(response.data!);\n      return response;\n    }).catch((error) => {\n      if (\n        mutationId === ref.current.mutationId &&\n        ref.current.isMounted\n      ) {\n        const result = {\n          loading: false,\n          error,\n          data: void 0,\n          called: true,\n          client,\n        };\n\n        if (!equal(ref.current.result, result)) {\n          setResult(ref.current.result = result);\n        }\n      }\n\n      if (ref.current.options?.onError || clientOptions.onError) {\n        ref.current.options?.onError?.(error);\n        executeOptions.onError?.(error);\n        // TODO(brian): why are we returning this here???\n        return { data: void 0, errors: error };\n      }\n\n      throw error;\n    });\n  }, []);\n\n  const reset = useCallback(() => {\n    setResult({ called: false, loading: false, client });\n  }, []);\n\n  useEffect(() => {\n    ref.current.isMounted = true;\n\n    return () => {\n      ref.current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n","import * as PropTypes from 'prop-types';\n\nimport { OperationVariables } from '../../core';\nimport { SubscriptionComponentOptions } from './types';\nimport { useSubscription } from '../hooks';\n\nexport function Subscription<TData = any, TVariables = OperationVariables>(\n  props: SubscriptionComponentOptions<TData, TVariables>\n) {\n  const result = useSubscription(props.subscription, props);\n  return props.children && result ? props.children(result) : null;\n}\n\nexport interface Subscription<TData, TVariables> {\n  propTypes: PropTypes.InferProps<SubscriptionComponentOptions<TData, TVariables>>;\n}\n\nSubscription.propTypes = {\n  subscription: PropTypes.object.isRequired,\n  variables: PropTypes.object,\n  children: PropTypes.func,\n  onSubscriptionData: PropTypes.func,\n  onSubscriptionComplete: PropTypes.func,\n  shouldResubscribe: PropTypes.oneOfType([PropTypes.func, PropTypes.bool])\n} as Subscription<any, any>[\"propTypes\"];\n","import '../../utilities/globals';\nimport { useState, useRef, useEffect } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { equal } from '@wry/equality';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport {\n  SubscriptionHookOptions,\n  SubscriptionResult\n} from '../types/types';\nimport { OperationVariables } from '../../core';\nimport { useApolloClient } from './useApolloClient';\n\nexport function useSubscription<TData = any, TVariables = OperationVariables>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<TData, TVariables>,\n) {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = useState<SubscriptionResult<TData>>({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  const [observable, setObservable] = useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const canResetObservableRef = useRef(false);\n  useEffect(() => {\n    return () => {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n\n  const ref = useRef({ client, subscription, options });\n  useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip) {\n      if (!options?.skip !== !ref.current.options?.skip || canResetObservableRef.current) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options?.variables,\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (\n      (shouldResubscribe !== false &&\n        (client !== ref.current.client ||\n          subscription !== ref.current.subscription ||\n          options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n          !options?.skip !== !ref.current.options?.skip ||\n          !equal(options?.variables, ref.current.options?.variables))) ||\n      canResetObservableRef.current\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(client.subscribe({\n        query: subscription,\n        variables: options?.variables,\n        fetchPolicy: options?.fetchPolicy,\n        context: options?.context,\n      }));\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options, canResetObservableRef.current]);\n\n  useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        ref.current.options?.onSubscriptionData?.({\n          client,\n          subscriptionData: result\n        });\n      },\n      error(error) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error,\n          variables: options?.variables,\n        });\n      },\n      complete() {\n        ref.current.options?.onSubscriptionComplete?.();\n      },\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [observable]);\n\n  return result;\n}\n","import { DocumentNode } from 'graphql';\n\nimport { parser, DocumentType } from '../parser';\nimport { withQuery } from './query-hoc';\nimport { withMutation } from './mutation-hoc';\nimport { withSubscription } from './subscription-hoc';\nimport { OperationOption, DataProps, MutateProps } from './types';\n\nexport function graphql<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = Partial<DataProps<TData, TGraphQLVariables>> &\n    Partial<MutateProps<TData, TGraphQLVariables>>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n): (\n  WrappedComponent: React.ComponentType<TProps & TChildProps>\n) => React.ComponentClass<TProps> {\n  switch (parser(document).type) {\n    case DocumentType.Mutation:\n      return withMutation(document, operationOptions);\n    case DocumentType.Subscription:\n      return withSubscription(document, operationOptions);\n    case DocumentType.Query:\n    default:\n      return withQuery(document, operationOptions);\n  }\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from '../parser';\nimport { DefaultContext } from '../../core/types';\nimport {\n  BaseMutationOptions,\n  MutationFunction,\n  MutationResult\n} from '../types/types';\nimport { Mutation } from '../components';\n\nimport {\n  defaultMapPropsToOptions,\n  getDisplayName,\n  calculateVariablesFromProps,\n  GraphQLBase\n} from './hoc-utils';\nimport { OperationOption, OptionProps, MutateProps } from './types';\nimport { ApolloCache } from '../../core';\n\nexport function withMutation<\n  TProps extends TGraphQLVariables | {} = {},\n  TData extends Record<string, any> = {},\n  TGraphQLVariables = {},\n  TChildProps = MutateProps<TData, TGraphQLVariables>,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n\n  const {\n    options = defaultMapPropsToOptions,\n    alias = 'Apollo'\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n  if (typeof mapPropsToOptions !== 'function')\n    mapPropsToOptions = () => options as BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      render() {\n        let props = this.props as TProps;\n        const opts = mapPropsToOptions(props) as BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props) as TGraphQLVariables;\n        }\n\n        return (\n          <Mutation ignoreResults {...opts} mutation={document}>\n            {(\n              mutate: MutationFunction<TData, TGraphQLVariables>,\n              { data, ...r }: MutationResult<TData>\n            ) => {\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Mutation component's shape here to replicate that\n              // this matches the query HoC\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'mutate';\n              const resultName = operationOptions.name\n                ? `${name}Result`\n                : 'result';\n              let childProps = ({\n                [name]: mutate,\n                [resultName]: result\n              } as any) as TChildProps;\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: mutate,\n                  [resultName]: result,\n                  ownProps: props\n                };\n                childProps = operationOptions.props(newResult) as any;\n              }\n\n              return <WrappedComponent {...props} {...childProps} />;\n            }}\n          </Mutation>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from '../parser';\nimport { BaseQueryOptions } from '../types/types';\nimport { Subscription } from '../components';\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip\n} from './hoc-utils';\nimport { OperationOption, OptionProps, DataProps } from './types';\n\nexport function withSubscription<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo',\n    shouldResubscribe\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseQueryOptions;\n  if (typeof mapPropsToOptions !== 'function')\n    mapPropsToOptions = () => options as BaseQueryOptions;\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') mapPropsToSkip = () => skip as any;\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<\n      TProps,\n      TChildProps,\n      { resubscribe: boolean }\n    > {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      constructor(props: TProps) {\n        super(props);\n        this.state = { resubscribe: false };\n      }\n\n      updateResubscribe(resubscribe: boolean) {\n        this.setState({ resubscribe });\n      }\n\n      componentDidUpdate(prevProps: TProps) {\n        const resubscribe = !!(\n          shouldResubscribe &&\n          shouldResubscribe(prevProps, this.props)\n        );\n        if (this.state.resubscribe !== resubscribe) {\n          this.updateResubscribe(resubscribe);\n        }\n      }\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip\n          ? Object.create(null)\n          : mapPropsToOptions(props);\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n        return (\n          <Subscription\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            subscription={document}\n            shouldResubscribe={this.state.resubscribe}\n          >\n            {({ data, ...r }: any) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance\n                });\n              }\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...(props as TProps)}\n                    {...({} as TChildProps)}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: result,\n                  ownProps: props as TProps\n                };\n                lastResultProps = operationOptions.props(\n                  newResult,\n                  lastResultProps\n                );\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...(props as TProps)}\n                  {...(childProps as TChildProps)}\n                />\n              );\n            }}\n          </Subscription>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n","import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from '../parser';\nimport { BaseQueryOptions } from '../types/types';\nimport { Query } from '../components';\nimport {\n  getDisplayName,\n  GraphQLBase,\n  calculateVariablesFromProps,\n  defaultMapPropsToOptions,\n  defaultMapPropsToSkip\n} from './hoc-utils';\nimport { OperationOption, OptionProps, DataProps } from './types';\n\nexport function withQuery<\n  TProps extends TGraphQLVariables | {} = {},\n  TData = {},\n  TGraphQLVariables = {},\n  TChildProps = DataProps<TData, TGraphQLVariables>\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n  const {\n    options = defaultMapPropsToOptions,\n    skip = defaultMapPropsToSkip,\n    alias = 'Apollo'\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseQueryOptions;\n  if (typeof mapPropsToOptions !== 'function') {\n    mapPropsToOptions = () => options as BaseQueryOptions;\n  }\n\n  let mapPropsToSkip = skip as (props: any) => boolean;\n  if (typeof mapPropsToSkip !== 'function') {\n    mapPropsToSkip = () => skip as any;\n  }\n\n  // allow for advanced referential equality checks\n  let lastResultProps: TChildProps | void;\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n\n      render() {\n        let props = this.props;\n        const shouldSkip = mapPropsToSkip(props);\n        const opts = shouldSkip\n          ? Object.create(null)\n          : { ...mapPropsToOptions(props) };\n\n        if (!shouldSkip && !opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return (\n          <Query\n            {...opts}\n            displayName={graphQLDisplayName}\n            skip={shouldSkip}\n            query={document}\n          >\n            {({ client: _, data, ...r }: any) => {\n              if (operationOptions.withRef) {\n                this.withRef = true;\n                props = Object.assign({}, props, {\n                  ref: this.setWrappedInstance\n                });\n              }\n\n              // if we have skipped, no reason to manage any reshaping\n              if (shouldSkip) {\n                return (\n                  <WrappedComponent\n                    {...(props as TProps)}\n                    {...({} as TChildProps)}\n                  />\n                );\n              }\n\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Query components shape here to replicate that\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'data';\n              let childProps = { [name]: result };\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: result,\n                  ownProps: props as TProps\n                };\n                lastResultProps = operationOptions.props(\n                  newResult,\n                  lastResultProps\n                );\n                childProps = lastResultProps;\n              }\n\n              return (\n                <WrappedComponent\n                  {...(props as TProps)}\n                  {...(childProps as TChildProps)}\n                />\n              );\n            }}\n          </Query>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","getLocation","source","position","match","lineRegexp","line","column","exec","body","index","length","printLocation","location","printSourceLocation","start","sourceLocation","firstLineColumnOffset","locationOffset","whitespace","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","concat","name","lines","split","locationLine","subLineIndex","Math","floor","subLineColumnNum","subLines","i","push","slice","printPrefixedLines","map","subLine","existingLines","filter","_ref","undefined","padLen","max","apply","_ref2","_ref3","str","prefix","join","len","Array","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","enumerable","_defineProperty","key","value","defineProperty","configurable","writable","_defineProperties","target","props","descriptor","_possibleConstructorReturn","self","call","_assertThisInitialized","ReferenceError","_wrapNativeSuper","Class","_cache","Map","fn","Function","toString","indexOf","TypeError","has","get","set","Wrapper","_construct","arguments","_getPrototypeOf","this","create","_setPrototypeOf","Parent","args","_isNativeReflectConstruct","Reflect","construct","a","instance","bind","sham","Proxy","Date","e","o","p","setPrototypeOf","__proto__","getPrototypeOf","GraphQLError","_Error","subClass","superClass","_inherits","Constructor","protoProps","staticProps","_super","Derived","hasNativeReflectConstruct","result","Super","NewTarget","_createSuper","message","nodes","positions","path","originalError","extensions","_nodeLocations","_nodeLocations2","_nodeLocations3","_this","_classCallCheck","undefinedIfEmpty","isArray","nodeLocations","_i2","_this$nodes","loc","locations","pos","originalExtensions","forEach","getOwnPropertyDescriptors","defineProperties","_objectSpread","stack","Error","captureStackTrace","error","output","_i4","_error$nodes2","node","_i6","_error$locations2","printError","SYMBOL_TO_STRING_TAG","array","syntaxError","description","Kind","freeze","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","FIELD_DEFINITION","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","DIRECTIVE_DEFINITION","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","TokenKind","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","BLOCK_STRING","COMMENT","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","SCHEMA","SCALAR","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","Lexer","startOfFileToken","Token","lastToken","token","lineStart","_proto","advance","lookahead","kind","_token$next","next","readToken","printCharCode","code","isNaN","JSON","stringify","String","fromCharCode","toUpperCase","lexer","prev","bodyLength","end","charCodeAt","_line","_col","readComment","readBlockString","readString","readNumber","readName","unexpectedCharacterMessage","col","firstCode","isFloat","readDigits","isNameStart","b","c","d","chunkStart","charCode","char2hex","invalidSequence","rawValue","dedentBlockStringValue","Parser","options","sourceObj","isSource","Source","_lexer","_options","parseName","expectToken","parseDocument","definitions","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","operation","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseValueLiteral","selections","parseSelection","parseFragment","parseField","alias","nameOrAlias","parseArguments","isConst","item","parseConstArgument","parseArgument","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","parseList","parseObject","parseStringLiteral","block","values","any","_this2","fields","parseObjectField","parseDirective","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","_this$_options2","allowLegacySDLImplementsInterfaces","types","delimitedMany","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","startToken","_this$_options4","noLocation","Location","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","delimiterKind","isPunctuatorTokenKind","docCache","fragmentSourceMap","printFragmentWarnings","normalize","string","replace","trim","processFragments","ast","seenKeys","Set","fragmentDefinition","fragmentName","sourceKey","substring","sourceKeySet","console","warn","add","cacheKey","parsed","parse","allowLegacyFragmentVariables","doc","workSet","endToken","stripLoc","gql","literals","arg","gql_1","extras","clear","_taggedTemplateLiteral","strings","raw","DocumentType","cache","operationName","Query","Mutation","Subscription","parser","document","variables","cached","__DEV__","invariant","fragments","queries","mutations","subscriptions","_i","x","definition","payload","verifyDocumentType","requiredOperationName","didWarnUncachedGetSnapshot","useSyncExternalStore","React","subscribe","getSnapshot","getServerSnapshot","inst","forceUpdate","canUseLayoutEffect","assign","checkIfSnapshotChanged","_a","useApolloClient","override","context","useContext","getApolloContext","client","hasOwnProperty","useQuery","query","stateRef","useRef","current","InternalState","state","useState","setTick","tick","useInternalState","previous","asyncResolveFns","optionsToIgnoreOnce","canUseWeakSet","WeakSet","ssrDisabledResult","maybeDeepFreeze","loading","data","networkStatus","NetworkStatus","skipStandbyResult","toQueryResultCache","canUseWeakMap","WeakMap","previousResult","previousData","Promise","resolve","watchQueryOptions","renderPromises","useOptions","obsQuery","useObservableQuery","useCallback","onNext","getCurrentResult","equal","setResult","subscription","onError","last","unsubscribe","resetLastResults","disableNetworkFetches","unsafeHandlePartialRefetch","queryResult","toQueryResult","size","createWatchQueryOptions","queryHookOptions","currentWatchQueryOptions","observable","delete","reobserve","getObsQueryOptions","onCompleted","ssr","skip","fetchPolicy","toMerge","globalDefaults","defaultOptions","watchQuery","compact","reduce","mergeOptions","otherOptions","getDefaultFetchPolicy","_c","_d","initialFetchPolicy","_b","getSSRObservable","obsQueryFields","useMemo","refetch","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","ssrAllowed","registerSSRObservable","addObservableQueryPromise","nextResult","handleErrorOrCompleted","resultWithoutPartial","called","isNonEmptyArray","errors","ApolloError","graphQLErrors","partial","partialRefetch","children","propTypes","PropTypes","notifyOnNetworkStatusChange","pollInterval","returnPartialData","defaultMapPropsToOptions","defaultMapPropsToSkip","getDisplayName","WrappedComponent","displayName","calculateVariablesFromProps","variableName","variableProp","setWrappedInstance","__extends","GraphQLBase","withRef","wrappedInstance","ref","mutation","mutationId","isMounted","execute","executeOptions","baseOptions","ignoreResults","clientOptions","mutate","then","response","result_1","catch","result_2","reset","useEffect","__assign","useMutation","runMutation","setObservable","canResetObservableRef","shouldResubscribe","fetchResult","onSubscriptionData","subscriptionData","complete","onSubscriptionComplete","useSubscription","graphql","operationOptions","mapPropsToOptions","graphQLDisplayName","GraphQL","opts","r","resultName","childProps","newResult","hoistNonReactStatics","withMutation","lastResultProps","mapPropsToSkip","resubscribe","setState","prevProps","updateResubscribe","shouldSkip","withSubscription","withQuery","optimisticResponse","refetchQueries","awaitRefetchQueries","update"],"sourceRoot":""}